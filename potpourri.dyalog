vin ← {
    ⍝ Weights of each number according to its position
    weights ← 8 7 6 5 4 3 2 10 0 9 8 7 6 5 4 3 2
    ⍝ The table of letter -> number substitutions
    ⍝ used to translate a VIN into a sequence of digits
    substitutions ← (0@(9 15 17 19)) 27⍴⍳9
    ⍝ Converts a single character to its corresponding
    ⍝ numeric value
    to_numeral ← {
        ⍵≤64: ⍵-48
        substitutions ⊃⍨ (⊢+19∘≤) ⍵-64
    }∘⎕UCS
    ⍝ Computes the check digit of a vin.
    check_digit ← {
       ⍝ The check digit may be 10 as a special case,
       ⍝ which is mapped to 'X'.
        to_char ← {
            ⍵≡10:'X'
            ⎕UCS 48+⍵
        }
        to_char 11|weights +.× to_numeral¨⍵
    }
    ⍝ Inserts the check digit to the 9th index
    set_check ← { (8∘↑,⍺,8∘↓) ⍵ }
    ⍝ Initializes a check digit for an unchecked VIN
    initialize ← { (check_digit '0' set_check ⍵) set_check ⍵ }
    ⍝ Verifies the correctness for a checked VIN
    verify ← check_digit≡9∘⊃
    ∨/~⍵∊⎕A,⎕D: ¯1
    16≡≢⍵: initialize ⍵
    17≡≢⍵: verify ⍵
    ¯1
}

sortVersions ← {
    ⍝ Regex pattern to extract the structure of a version string.
    ⍝ The first group captures the package name, the following three
    ⍝ capture the 'major.minor.patch' numbers. The optional patch
    ⍝ information is matched but not captured.
    pattern ← '([^-]+\-[^-]+)\-(\d+)\.(\d+)\.(\d+)(?:\-.*)?'
    ⍝ Fetches a capture group from a regex namespace returned by ⎕R
    ⍝ Note that group 1 in regex is the whole match, so the first
    ⍝ matched subgroup is actually at index 2
    group ← { ⍵.((⍺⊃Lengths)↑(⍺⊃Offsets)↓Block) }
    ⍝ Returns the argument vector ⍵ sorted by the
    ⍝ given capture group ⍺ under some transformation function ⍺⍺.
    sort_group_by ← { ⍵[⍋⍺⍺¨(pattern ⎕R (⍺∘group))¨⍵] }
    ⍝ Safely parse an integer from a string (not a fan of ⍎)
    parse_int ← 10⊥ ¯1+ ⎕D∘⍳
    ⍝ First sort the packages numerically by groups 5, 4 and 3
    ⍝ (the patch, minor and major version numbers)
    sort_int ← parse_int sort_group_by
    by_version ← 3 sort_int 4 sort_int 5 sort_int ⍵
    ⍝ Then sort (a.k.a group) by the package name
    2 ⊢sort_group_by by_version
}

makeChange ← {
    ⍝ Special case: 0≡≢⍺
    ⍝ If ⍵≡0, then one (empty) result exists
    (⍵≡0)∧⍺≡⍬:1 0⍴0
    ⍝ Else, no valid results exist
    ⍺≡⍬:0 1⍴0
    ⍝ Base case: 1≡≢⍺
    ⍝ If the final coin cannot evenly fill the
    ⍝ target, no valid results exist
    (0≢⍵|⍨⊃⍺)∧1≡≢⍺:0 1⍴0
    ⍝ Else, exactly one valid result exists
    ⍝ (the one that evenly fills the target)
    1≡≢⍺:1 1⍴⍵÷⊃⍺
    ⍝ Recursive case: 1<≢⍺
    ⍝ Pick the next coin in the given list,
    ⍝ which is guaranteed to be the maximum.
    coin rest ← ¯1(↑{⍺ ⍵}↓)⍺
    ⍝ The algorithm recurses on each possible
    ⍝ choice of C such that ⍵≥coin×C and
    ⍝ returns all solutions to the smaller task.
    choices ← 0,⍳⌊⍵÷coin
    perms ← (↓rest∘∇)¨⍵-choices×coin
    ⍝ Every valid solution to the smaller task
    ⍝ yields a solution to the current task.
    ↑(⊃,/)perms,¨¨choices
}

partition ← {
    ⍝ Wrangle ⍺ to have the proper structure;
    ⍝ enclose and enlist to a 2-depth vector
    spec ← ,∘⊂∘,⍣(1≥|≡,⍺)⊢⍺
    ⍝ The move and origin default as specified
    ⍝ in the problem description.
    shape ← ⊃spec
    move ← {⍵:(≢shape)⍴1 ⋄ 2⊃spec}2>≢spec
    origin ← ⍵{⍵:(≢⍴⍺)⍴1 ⋄ 3⊃spec}3>≢spec
    ⍝ Handle the origin first, since it is
    ⍝ based on the shape of ⍵
    crop ← ⍵↓⍨origin-1
    ⍝ Align ⍵ to the appropriate shape:
    ⍝ Crop extra dimensions by flattening the
    ⍝ first n dimensions down into one.
    extra_dims ← (≢⍴⍵)-⍴shape
    factor ← ×/extra_dims↑⍴crop
    ⍝ Note that if the number of extra dimensions
    ⍝ is negative, this raises an index error.
    flat_shape ← factor∘×@1⊢extra_dims↓⍴crop
    flat ← flat_shape⍴crop
    ⍝ Rotates each axis of ⍵ by the specified amount in ⍺
    rot_each ← ↓↑⍨⍴⍤⊢××⍤⊣+0=⊣
    ⍝ In order to ignore the padding cells
    ⍝ introduced by stencil, whilst maintaining
    ⍝ the correct phase offset, we will pad the
    ⍝ input and filter the output.
    ⍝
    ⍝ The padding is chosen such that the
    ⍝ output of stencil will have the minimum
    ⍝ number of "junk" rows and columns, which
    ⍝ can then be consistently cropped off.
    ⍝
    ⍝ It's not always possible to have exactly
    ⍝ one junk row, for which the kernels align with
    ⍝ the origin only after at the third position.
    ⍝ Number of padding cells generated by stencil
    stencil_pad ← ⌈¯1+shape÷2
    ⍝ Number of "junk" windows in the stencil output
    pad_entries ← ⌈stencil_pad÷move
    ⍝ Number of extra padding cells required to align the windows
    extra_pad ← stencil_pad-⍨move×pad_entries
    ⍝ Generate padding cells at the end of each axis by
    ⍝ reshaping, then shift them to the start and end equally.
    total_shape ← (2×extra_pad)+⍴flat
    padded ← (-extra_pad)rot_each total_shape↑flat
    ⍝ Finally, crop and flatten the stenciled windows
    windows ← {⊂⍵}⌺(↑shape move)⊢padded
    desired ← (-pad_entries)↓pad_entries↓windows
    ,desired
}
